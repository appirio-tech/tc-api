/*
 * Copyright (C) 2013 - 2014 TopCoder Inc., All Rights Reserved.
 *
 * @version 1.4
 * @author Sky_, Ghost_141
 * changes in 1.1:
 * - remove studio tests
 * changes in 1.2:
 * Merge the tests for Search Studio Challenges, Get Studio Challenge Detail, Get Software Challenge Detail API in this file.
 * changes in 1.3:
 * update the test for private challenge support.
 * changes in 1.4:
 * update the test for search private challenges support
 */
"use strict";
/*global describe, it, before, beforeEach, after, afterEach, __dirname */
/*jslint node: true, stupid: true, unparam: true */

/**
 * Module dependencies.
 */
var request = require('supertest');
var assert = require('chai').assert;
var expect = require('chai').expect;
var async = require('async');
var _ = require('underscore');
var testHelper = require('./helpers/testHelper');

var API_ENDPOINT = process.env.API_ENDPOINT || 'http://localhost:8080';
var SQL_DIR = __dirname + "/sqls/challenges/";
var TCS_CATALOG = "tcs_catalog";
var TCS_DW = 'tcs_dw';
var CORPORATE_OLTP = 'corporate_oltp';
var ListType = { ACTIVE: "ACTIVE", OPEN: "OPEN", UPCOMING: "UPCOMING", PAST: "PAST" };
var software_collection_length = {};
software_collection_length[ListType.ACTIVE] = 4;
software_collection_length[ListType.OPEN] = 4;
software_collection_length[ListType.UPCOMING] = 2;
software_collection_length[ListType.PAST] = 2;

describe('Test Challenges API', function () {
    this.timeout(60000); // The api with testing remote db could be quit slow


    /**
     * Assert challenge properties.
     * Challenges are generated by pattern that depends on nr, isStudio, type and details parameters.
     * @param {Object} challenge - the challenge to check
     */
    function assertChallenge(challenge) {
        expect(challenge.challengeName).to.contain(challenge.challengeType);

        assert.ok(challenge.challengeId, "Invalid challengeId");
        assert.ok(challenge.projectId, "Invalid projectId");
        assert.ok(new Date(challenge.registrationEndDate).toString() !== "InvalidDate",
            "Invalid registrationEndDate");
        assert.ok(new Date(challenge.submissionEndDate).toString() !== "InvalidDate",
            "Invalid submissionEndDate");
        assert.ok(challenge.prize, "Invalid prize");
        assert.ok(challenge.prize.length, "Invalid prize.length");
    }

    /**
     * Assert response from given url.
     * It always expect 50 records
     * @param {String} type - the challenge type: "ACTIVE", "OPEN", "PAST", "UPCOMING"
     * @param {Function<err>} done the callback
     */
    function assertCollection(type, done) {
        request(API_ENDPOINT)
            .get('/v2/' +  'develop' + '/challenges?listType=' + type)
            .set('Accept', 'application/json')
            .expect('Content-Type', /json/)
            .expect(200)
            .end(function (err, res) {
                assert.ifError(err);
                var body = res.body;
                assert.equal(body.total, software_collection_length[type], 'total is not equal');
                assert.equal(body.pageIndex, 1);
                assert.equal(body.pageSize, 50);
                assert.ok(body.data);
                assert.equal(body.data.length, software_collection_length[type], 'data.length is not equal.');
                body.data.forEach(function (challenge) {
                    assertChallenge(challenge);
                });
                done();
            });
    }

    /**
     * Assert cmc value in response from given url.
     * @param {String} type - the challenge type: "ACTIVE", "OPEN", "PAST", "UPCOMING"
     * @param {Number} size - the count of expected elements
     * @param {String} cmc - the cmc to assert
     * @param {Function<err>} done the callback
     */
    function assertCMC(type, size, cmc, done) {
        request(API_ENDPOINT)
            .get('/v2/' + 'develop' + '/challenges?listType=' + type + "&cmcTaskId=" + cmc)
            .set('Accept', 'application/json')
            .expect('Content-Type', /json/)
            .expect(200)
            .end(function (err, res) {
                assert.ifError(err);
                var body = res.body, i;
                assert.equal(body.total, size);
                assert.ok(body.data);
                assert.equal(body.data.length, size);

                for (i = 0; i < size; i = i + 1) {
                    assert.equal(body.data[i].cmcTaskId, cmc);
                }
                done();
            });
    }

    /**
     * Create request to search Studio challenges API and assert 400 http code
     * @param {String} queryString - the query string
     * @param {Function} done - the callback function
     */
    function assert400(queryString, done) {
        request(API_ENDPOINT)
            .get('/v2/design/challenges?' + queryString)
            .set('Accept', 'application/json')
            .expect('Content-Type', /json/)
            .expect(400)
            .end(done);
    }

    /**
     * Helper method for validating Studio challenge result for current test data
     * @param {String} queryString - the query string
     * @param {Array} challenges - the array of expected challenges. e.g [1, 2]
     * @param {String} type - the list type
     * @param {Number} total - the expected total count
     * @param {Number} pageIndex - the expected pageIndex
     * @param {Number} pageSize - the expected pageSize
     * @param {Function} done - the callback function
     */
    function validateResult(queryString, challenges, type, total, pageIndex, pageSize, done) {
        request(API_ENDPOINT)
            .get('/v2/design/challenges?' + queryString)
            .set('Accept', 'application/json')
            .expect('Content-Type', /json/)
            .expect(200)
            .end(function (err, res) {
                if (err) {
                    done(err);
                    return;
                }
                var results = res.body.data, i, item;
                assert.lengthOf(results, challenges.length, "invalid data.length");
                assert.equal(res.body.total, total, "invalid total");
                assert.equal(res.body.pageIndex, pageIndex, "invalid pageIndex");
                assert.equal(res.body.pageSize, pageSize, "invalid pageSize");
                for (i = 0; i < results.length; i = i + 1) {
                    item = results[i];
                    assert.isString(item.challengeType, "invalid type for result: " + i);
                    assert.isString(item.challengeName);
                    assert.equal(item.challengeName, "Studio Contest " + challenges[i],
                        "invalid challengeName for result: " + i);
                    assert.ok(new Date(item.postingDate), "invalid postingDate for result: " + i);
                    assert.ok(new Date(item.registrationEndDate), "invalid registrationEndDate for result: " + i);
                    assert.ok(new Date(item.submissionEndDate), "invalid submissionEndDate for result: " + i);
                    assert.isNumber(item.prize[0], "invalid prize for result: " + i);
                }
                done();
            });
    }

    describe('', function () {

        /**
         * Clear database
         * @param {Function<err>} done the callback
         */
        function clearDb(done) {
            async.waterfall([
                function (cb) {
                    testHelper.runSqlFile(SQL_DIR + 'tcs_catalog__clean', TCS_CATALOG, cb);
                }, function (cb) {
                    testHelper.runSqlFile(SQL_DIR + 'tcs_dw__clean', TCS_DW, cb);
                }
            ], done);
        }

        /**
         * This function is run before all tests.
         * Generate tests data.
         * @param {Function<err>} done the callback
         */
        before(function (done) {
            async.waterfall([
                clearDb,
                function (cb) {
                    var files = testHelper.generatePartPaths(SQL_DIR + "tcs_catalog__insert_test_data", "", 2);
                    testHelper.runSqlFiles(files, TCS_CATALOG, cb);
                }, function (cb) {
                    testHelper.runSqlFile(SQL_DIR + 'tcs_dw__insert_test_data', TCS_DW, cb);
                }
            ], done);

        });

        /**
         * This function is run after all tests.
         * Clean up all data.
         * @param {Function<err>} done the callback
         */
        after(function (done) {
            clearDb(done);
        });

        /**
         * Tests for software challenges
         */
        describe('-- Search Software Challenges --', function () {

            /**
             * Test develop/challenges?listType=active
             */
            it('should return 4 ACTIVE challenges', function (done) {
                assertCollection(ListType.ACTIVE, done);
            });

            /**
             * Test develop/challenges?listType=open
             */
            it('should return 4 OPEN challenges', function (done) {
                assertCollection(ListType.OPEN,  done);
            });

            /**
             * Test develop/challenges?listType=past
             */
            it('should return 2 PAST challenges', function (done) {
                assertCollection(ListType.PAST, done);
            });

            /**
             * Test develop/challenges?listType=upcoming
             */
            it('should return 2 UPCOMING challenges', function (done) {
                assertCollection(ListType.UPCOMING, done);
            });


            /**
             * Test develop/challenges?listType=active&cmcTaskId=cmc
             */
            it('should return 5 ACTIVE challenges with cmcTaskId=cmc', function (done) {
                assertCMC("ACTIVE", 3, "cmc", done);
            });

            /**
             * Test develop/challenges?listType=open&cmcTaskId=cmc
             */
            it('should return 3 OPEN challenges with cmcTaskId=cmc', function (done) {
                assertCMC("OPEN", 3, "cmc", done);
            });

            /**
             * Test develop/challenges?listType=past&cmcTaskId=cmc
             */
            it('should return 2 PAST challenges with cmcTaskId=cmc', function (done) {
                assertCMC("PAST", 2, "cmc", done);
            });

            /**
             * Test develop/challenges?listType=upcoming&cmcTaskId=cmc
             */
            it('should return 2 UPCOMING challenges with cmcTaskId=cmc', function (done) {
                assertCMC("UPCOMING", 1, "cmc", done);
            });
        });

        describe("-- Search Design Challenges --", function () {

            /**
             * /v2/design/challenges?listType=active
             */
            it("should return results for ?listType=active", function (done) {
                validateResult("listType=active", [1, 2, 4], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=aCtiVe
             */
            it("should return results for ?listType=aCtiVe", function (done) {
                validateResult("listType=aCtiVe", [1, 2, 4], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=challengeName
             */
            it("should return results for ?listType=active&sortColumn=challengeName", function (done) {
                validateResult("listType=active&sortColumn=challengeName", [1, 2, 4], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=challengeName&sortOrder=desc
             */
            it("should return results for ?listType=active&sortColumn=challengeName&sortOrder=desc", function (done) {
                validateResult("listType=active&sortColumn=challengeName&sortOrder=desc", [4, 2, 1], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=challengeName&sortOrder=dESc
             */
            it("should return results for ?listType=active&sortColumn=challengeName&sortOrder=dESc", function (done) {
                validateResult("listType=active&sortColumn=challengeName&sortOrder=dESc", [4, 2, 1], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=challengeType
             */
            it("should return results for ?listType=active&sortColumn=challengeType", function (done) {
                validateResult("listType=active&sortColumn=challengeType", [1, 4, 2], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=challengeType&sortOrder=desc
             */
            it("should return results for ?listType=active&sortColumn=challengeType&sortOrder=desc", function (done) {
                validateResult("listType=active&sortColumn=challengeType&sortOrder=desc", [2, 1, 4], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=registrationEndDate
             */
            it("should return results for ?listType=active&sortColumn=registrationEndDate", function (done) {
                validateResult("listType=active&sortColumn=registrationEndDate", [4, 1, 2], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=registrationEndDate&sortOrder=desc
             */
            it("should return results for ?listType=active&sortColumn=registrationEndDate&sortOrder=desc", function (done) {
                validateResult("listType=active&sortColumn=registrationEndDate&sortOrder=desc", [2, 1, 4], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=submissionEndDate
             */
            it("should return results for ?listType=active&sortColumn=submissionEndDate", function (done) {
                validateResult("listType=active&sortColumn=submissionEndDate", [4, 1, 2], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=submissionEndDate&sortOrder=desc
             */
            it("should return results for ?listType=active&sortColumn=submissionEndDate&sortOrder=desc", function (done) {
                validateResult("listType=active&sortColumn=submissionEndDate&sortOrder=desc", [2, 1, 4], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=finalFixEndDate
             */
            it("should return results for ?listType=active&sortColumn=finalFixEndDate", function (done) {
                validateResult("listType=active&sortColumn=finalFixEndDate", [1, 2, 4], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=finalFixEndDate&sortOrder=desc
             */
            it("should return results for ?listType=active&sortColumn=finalFixEndDate&sortOrder=desc", function (done) {
                validateResult("listType=active&sortColumn=finalFixEndDate&sortOrder=desc", [1, 2, 4], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=challengeId
             */
            it("should return results for ?listType=active&sortColumn=challengeId", function (done) {
                validateResult("listType=active&sortColumn=challengeId", [1, 2, 4], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=challengeId&sortOrder=desc
             */
            it("should return results for ?listType=active&sortColumn=challengeId&sortOrder=desc", function (done) {
                validateResult("listType=active&sortColumn=challengeId&sortOrder=desc", [4, 2, 1], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=prize1
             */
            it("should return results for ?listType=active&sortColumn=prize1", function (done) {
                validateResult("listType=active&sortColumn=prize1", [2, 1, 4], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=prize1&sortOrder=desc
             */
            it("should return results for ?listType=active&sortColumn=prize1&sortOrder=desc", function (done) {
                validateResult("listType=active&sortColumn=prize1&sortOrder=desc", [1, 4, 2], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=digitalRunPoints
             */
            it("should return results for ?listType=active&sortColumn=digitalRunPoints", function (done) {
                validateResult("listType=active&sortColumn=digitalRunPoints", [2, 1, 4], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=digitalRunPoints&sortOrder=desc
             */
            it("should return results for ?listType=active&sortColumn=digitalRunPoints&sortOrder=desc", function (done) {
                validateResult("listType=active&sortColumn=digitalRunPoints&sortOrder=desc", [1, 4, 2], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=cmcTaskId
             */
            it("should return results for ?listType=active&sortColumn=cmcTaskId", function (done) {
                validateResult("listType=active&sortColumn=cmcTaskId", [4, 2, 1], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=cmcTaskId&sortOrder=desc
             */
            it("should return results for ?listType=active&sortColumn=cmcTaskId&sortOrder=desc", function (done) {
                validateResult("listType=active&sortColumn=cmcTaskId&sortOrder=desc", [1, 2, 4], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=currentStatus
             */
            it("should return results for ?listType=active&sortColumn=currentStatus", function (done) {
                validateResult("listType=active&sortColumn=currentStatus", [1, 2, 4], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&sortColumn=currentStatus&sortOrder=desc
             */
            it("should return results for ?listType=active&sortColumn=currentStatus&sortOrder=desc", function (done) {
                validateResult("listType=active&sortColumn=currentStatus&sortOrder=desc", [1, 2, 4], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?pageIndex=1&pageSize=1
             */
            it("should return results for ?pageIndex=1&pageSize=1", function (done) {
                validateResult("pageIndex=1&pageSize=1", [1], "ACTIVE", 2, 1, 1, done);
            });

            /**
             * /v2/design/challenges?pageIndex=2&pageSize=1
             */
            it("should return results for ?pageIndex=2&pageSize=1", function (done) {
                validateResult("pageIndex=2&pageSize=1", [2], "ACTIVE", 2, 2, 1, done);
            });

            /**
             * /v2/design/challenges?pageIndex=-1
             */
            it("should return results for ?pageIndex=-1", function (done) {
                validateResult("pageIndex=-1", [1, 2], "ACTIVE", 2, 1, 2147483647, done);
            });

            /**
             * /v2/design/challenges?listType=OPEN
             */
            it("should return results for ?listType=OPEN", function (done) {
                validateResult("listType=OPEN", [1, 2], "OPEN", 2, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=PAST
             */
            it("should return results for ?listType=PAST", function (done) {
                validateResult("listType=PAST", [5], "PAST", 1, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=UPCOMING
             */
            it("should return results for ?listType=UPCOMING", function (done) {
                validateResult("listType=UPCOMING", [3], "UPCOMING", 1, 1, 50, done);
            });


            /**
             * /v2/design/challenges?listType=active&challengeType=Banners/icons
             */
            it("should return results for ?listType=active&challengeType=Banners/icons", function (done) {
                validateResult("listType=active&challengeType=Banners/icons", [1, 4], "ACTIVE", 2, 1, 50, done);
            });


            /**
             * /v2/design/challenges?listType=active&challengeName=contest 1
             */
            it("should return results for ?listType=active&challengeName=contest 1", function (done) {
                validateResult("listType=active&challengeName=contest 1", [1], "ACTIVE", 1, 1, 50, done);
            });


            /**
             * /v2/design/challenges?listType=active&prizeLowerBound=1000
             */
            it("should return results for ?listType=active&prizeLowerBound=1000", function (done) {
                validateResult("listType=active&prizeLowerBound=1000", [1, 4], "ACTIVE", 2, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&prizeUpperBound=1200
             */
            it("should return results for ?listType=active&prizeUpperBound=1200", function (done) {
                validateResult("listType=active&prizeUpperBound=1200", [1, 2, 4], "ACTIVE", 3, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=active&cmcTaskId=cmc
             */
            it("should return results for ?listType=active&cmcTaskId=cmc", function (done) {
                validateResult("listType=active&cmcTaskId=cmc", [1], "ACTIVE", 1, 1, 50, done);
            });

            /**
             * /v2/design/challenges?listType=open&cmcTaskId=cmc
             */
            it("should return results for ?listType=open&cmcTaskId=cmc", function (done) {
                validateResult("listType=open&cmcTaskId=cmc", [1], "OPEN", 1, 1, 50, done);
            });


            /**
             * /v2/design/challenges?listType=open&prizeLowerBound=800
             */
            it("should return results for ?listType=open&prizeLowerBound=800", function (done) {
                validateResult("listType=open&prizeLowerBound=800", [1, 2], "OPEN", 2, 1, 50, done);
            });


            /**
             * /v2/design/challenges?listType=xyz
             */
            it("should return error 400 when listType is not valid value", function (done) {
                assert400("listType=xyz", done);
            });

            /**
             * /v2/design/challenges?pageSize=xyz
             */
            it("should return error 400 when pageSize is not number", function (done) {
                assert400("pageSize=xyz", done);
            });

            /**
             * /v2/design/challenges?pageSize=0
             */
            it("should return error 400 when pageSize is 0", function (done) {
                assert400("pageSize=0", done);
            });

            /**
             * /v2/design/challenges?pageSize=-1
             */
            it("should return error 400 when pageSize is -1", function (done) {
                assert400("pageSize=-1", done);
            });

            /**
             * /v2/design/challenges?pageSize=100000000000000000000
             */
            it("should return error 400 when pageSize is too big number", function (done) {
                assert400("pageSize=100000000000000000000", done);
            });

            /**
             * /v2/design/challenges?pageSize=1.123
             */
            it("should return error 400 when pageSize is float number", function (done) {
                assert400("pageSize=1.123", done);
            });

            /**
             * /v2/design/challenges?pageIndex=xyz
             */
            it("should return error 400 when pageIndex is not number", function (done) {
                assert400("pageIndex=xyz", done);
            });

            /**
             * /v2/design/challenges?pageIndex=0
             */
            it("should return error 400 when pageIndex is 0", function (done) {
                assert400("pageIndex=0", done);
            });

            /**
             * /v2/design/challenges?pageIndex=-2
             */
            it("should return error 400 when pageIndex is -2", function (done) {
                assert400("pageIndex=-2", done);
            });

            /**
             * /v2/design/challenges?pageIndex=100000000000000000000
             */
            it("should return error 400 when pageIndex is too big number", function (done) {
                assert400("pageIndex=100000000000000000000", done);
            });

            /**
             * /v2/design/challenges?pageIndex=1.123
             */
            it("should return error 400 when pageIndex is float number", function (done) {
                assert400("pageIndex=1.123", done);
            });

            /**
             * /v2/design/challenges?sortColumn=xyz
             */
            it("should return error 400 when sortColumn is invalid", function (done) {
                assert400("sortColumn=xyz", done);
            });

            /**
             * /v2/design/challenges?sortOrder=xyz
             */
            it("should return error 400 when sortOrder is invalid", function (done) {
                assert400("sortOrder=xyz", done);
            });

            /**
             * /v2/design/challenges?prizeLowerBound=xyz
             */
            it("should return error 400 when prizeLowerBound is not valid value", function (done) {
                assert400("prizeLowerBound=xyz", done);
            });

            /**
             * /v2/design/challenges?prizeUpperBound=xyz
             */
            it("should return error 400 when prizeUpperBound is not valid value", function (done) {
                assert400("prizeUpperBound=xyz", done);
            });

            /**
             * /v2/design/challenges?prizeLowerBound=-1
             */
            it("should return error 400 when prizeLowerBound is -1", function (done) {
                assert400("prizeLowerBound=-1", done);
            });

            /**
             * /v2/design/challenges?prizeUpperBound=-1
             */
            it("should return error 400 when prizeUpperBound is -1", function (done) {
                assert400("prizeUpperBound=-1", done);
            });

            /**
             * /v2/design/challenges?pageIndex=100&pageSize=100
             */
            it("should return empty result when no results returned", function (done) {
                request(API_ENDPOINT)
                    .get('/v2/design/challenges?pageIndex=100&pageSize=100')
                    .set('Accept', 'application/json')
                    .expect('Content-Type', /json/)
                    .expect(200)
                    .end(done);
            });

        });

        describe('-- Search Both Challenges --', function () {
            it('should return 7 Active challenges', function (done) {
                request(API_ENDPOINT)
                    .get('/v2/challenges?listType=active')
                    .set('Accept', 'application/json')
                    .expect('Content-Type', /json/)
                    .expect(200)
                    .end(function (err, res) {
                        var body = res.body;
                        assert.equal(body.total, 7, 'Invalid total number');
                        assert.equal(body.pageIndex, 1, 'Invalid pageIndex');
                        assert.equal(body.pageSize, 50, 'Invalid pageSize');
                        assert.equal(body.data.length, 7, 'Invalid data length');
                        done();
                    });
            });
            it('should return 6 Open challenges', function (done) {
                request(API_ENDPOINT)
                    .get('/v2/challenges?listType=open')
                    .set('Accept', 'application/json')
                    .expect('Content-Type', /json/)
                    .expect(200)
                    .end(function (err, res) {
                        var body = res.body;
                        assert.equal(body.total, 6, 'Invalid total number');
                        assert.equal(body.pageIndex, 1, 'Invalid pageIndex');
                        assert.equal(body.pageSize, 50, 'Invalid pageSize');
                        assert.equal(body.data.length, 6, 'Invalid data length');
                        done();
                    });
            });
            it('should return 3 Upcoming challenges', function (done) {
                request(API_ENDPOINT)
                    .get('/v2/challenges?listType=upcoming')
                    .set('Accept', 'application/json')
                    .expect('Content-Type', /json/)
                    .expect(200)
                    .end(function (err, res) {
                        var body = res.body;
                        assert.equal(body.total, 3, 'Invalid total number');
                        assert.equal(body.pageIndex, 1, 'Invalid pageIndex');
                        assert.equal(body.pageSize, 50, 'Invalid pageSize');
                        assert.equal(body.data.length, 3, 'Invalid data length');
                        done();
                    });
            });

            it('should return 3 Past challenges', function (done) {
                request(API_ENDPOINT)
                    .get('/v2/challenges?listType=past')
                    .set('Accept', 'application/json')
                    .expect('Content-Type', /json/)
                    .expect(200)
                    .end(function (err, res) {
                        var body = res.body;
                        assert.equal(body.total, 3, 'Invalid total number');
                        assert.equal(body.pageIndex, 1, 'Invalid pageIndex');
                        assert.equal(body.pageSize, 50, 'Invalid pageSize');
                        assert.equal(body.data.length, 3, 'Invalid data length');
                        done();
                    });
            });
        });
    });

    /**
     * Tests when there is a caller in request.
     */
    describe('--Search private challenges --', function () {

        var SQL_DIR = __dirname + '/sqls/privateChallenges/',
            heffan = "ad|132456",
            userSuper = "ad|132457",
            user = 'ad|132458',
            heffanAuthHeader = testHelper.generateAuthHeader({ sub: heffan }),
            superAuthHeader = testHelper.generateAuthHeader({ sub: userSuper }),
            userAuthHeader = testHelper.generateAuthHeader({ sub: user });

        function clearDb(done) {
            async.waterfall([
                function (cb) {
                    testHelper.runSqlFile(SQL_DIR + 'tcs_catalog__clean', TCS_CATALOG, cb);
                },
                function (cb) {
                    testHelper.runSqlFile(SQL_DIR + 'corporate_oltp__clean', CORPORATE_OLTP, cb);
                }
            ], function (err) {
                if (err) {
                    done(err);
                    return;
                }
                done();
            });
        }

        before(function (done) {
            async.waterfall([
                clearDb,
                function (cb) {
                    testHelper.runSqlFile(SQL_DIR + 'corporate_oltp__insert_test_data', CORPORATE_OLTP, cb);
                },
                function (cb) {
                    testHelper.runSqlFile(SQL_DIR + 'tcs_catalog__insert_test_data', TCS_CATALOG, cb);
                }
            ], done);
        });

        after(function (done) {
            clearDb(done);
        });

        /**
         * Create a http request and test it.
         * @param {String} url - the request url.
         * @param {Number} expectStatus - the expected request response status.
         * @param {Object} authHeader - the auth header for request.
         * @param {Function} cb - the call back function.
         */
        function createRequest(url, expectStatus, authHeader, cb) {
            var req = request(API_ENDPOINT)
                .get(url)
                .set('Accept', 'application/json');
            if (authHeader) {
                req.set('Authorization', authHeader);
            }
            req.expect('Content-Type', /json/)
                .expect(expectStatus)
                .end(cb);
        }

        /**
         * Get challenge id from giving response.
         * @param results the giving response.
         */
        function getChallengeIds(results) {
            return _.map(results, function (item) {
                return item.challengeId;
            });
        }

        /**
         * Should return private challenges for user 'heffan' and public challenges.
         */
        it('should return success results. The results should include private challenge that heffan can access and ' +
            'public challenges.', function (done) {
                createRequest('/v2/develop/challenges', 200, heffanAuthHeader, function (err, result) {
                    if (err) {
                        done(err);
                        return;
                    }
                    var actual = testHelper.getTrimmedData(result.res.text), challengeIds;
                    challengeIds = getChallengeIds(actual.data);
                    assert.sameMembers([2001, 2002, 2004], challengeIds, 'invalid response');
                    done();
                });
            });

        /**
         * Should return private challenges for user 'super' and public challenges.
         */
        it('should return success results. The results should include private challenge that super can access and ' +
            'public challenges.', function (done) {
                createRequest('/v2/develop/challenges', 200, superAuthHeader, function (err, result) {
                    if (err) {
                        done(err);
                        return;
                    }
                    var actual = testHelper.getTrimmedData(result.res.text), challengeIds;
                    challengeIds = getChallengeIds(actual.data);
                    assert.sameMembers([2002, 2004], challengeIds, 'invalid response');
                    done();
                });
            });

        /**
         * Should return private challenge for user 'user' and public chllenges.
         */
        it('should return success results. The results should only include public challenges since user can only ' +
            'access public challenges.', function (done) {
                createRequest('/v2/develop/challenges', 200, userAuthHeader, function (err, result) {
                    if (err) {
                        done(err);
                        return;
                    }
                    var actual = testHelper.getTrimmedData(result.res.text), challengeIds;
                    challengeIds = getChallengeIds(actual.data);
                    assert.sameMembers([2004], challengeIds, 'invalid response');
                    done();
                });
            });

        /**
         * Test when communityId is set. and the caller is in that group.
         */
        it('should return success results. The results should only include the challenges in group A.', function (done) {
            createRequest('/v2/develop/challenges?communityId=2001', 200, heffanAuthHeader, function (err, result) {
                if (err) {
                    done(err);
                    return;
                }
                var actual = testHelper.getTrimmedData(result.res.text), challengeIds;
                challengeIds = getChallengeIds(actual.data);
                assert.sameMembers([2001], challengeIds, 'invalid response');
                done();
            });
        });

        /**
         * Test when user is not in specific group.
         */
        it('should return unauthorized error. The user is not belong to group B.', function (done) {
            createRequest('/v2/develop/challenges?communityId=2001', 401, superAuthHeader, done);
        });

        /**
         * Test when the communityId is set but the caller is not passed.
         */
        it('should return 400 bad request error. The caller should be passed when communityId is set.', function (done) {
            createRequest('/v2/develop/challenges?communityId=2001', 400, null, done);
        });

        /**
         * Test when the caller is not in group.
         */
        it('should return 401 unauthorized error. The caller is not in the group.', function (done) {
            createRequest('/v2/develop/challenges?communityId=2001', 401, userAuthHeader, done);
        });

        /**
         * Test /v2/develop/challenges?communityId=abc
         */
        it('should return 400 bad request. The communityId is not number.', function (done) {
            createRequest('/v2/develop/challenges?communityId=abc', 400, heffanAuthHeader, done);
        });

        /**
         * Test /v2/develop/challenges?communityId=1.234
         */
        it('should return 400 bad request. The communityId is not integer.', function (done) {
            createRequest('/v2/develop/challenges?communityId=1.234', 400, heffanAuthHeader, done);
        });

        /**
         * Test /v2/develop/challenges?communityId=-1
         */
        it('should return 400 bad request. The communityId is not positive.', function (done) {
            createRequest('/v2/develop/challenges?communityId=-1', 400, heffanAuthHeader, done);
        });

        /**
         * Test /v2/develop/challenges?communityId=2147483648
         */
        it('should return 400 bad request. The communityId is too big.', function (done) {
            createRequest('/v2/develop/challenges?communityId=2147483648', 400, heffanAuthHeader, done);
        });
    });

    describe('', function () {
        /**
         * Tests for Software challenge detail
         */
        describe('-- Software Challenge Detail API --', function () {
            var SQL_DIR = __dirname + '/sqls/softwareChallengeDetail/',
                heffan = 'ad|132456',
                heffanAuthHeader = testHelper.generateAuthHeader({ sub: heffan }),
                user = 'ad|132458',
                userAuthHeader = testHelper.generateAuthHeader({ sub: user });

            function clearDb(done) {
                testHelper.runSqlFile(SQL_DIR + "tcs_catalog__delete.sql", TCS_CATALOG, done);
            }

            before(function (done) {
                async.waterfall([
                    clearDb,
                    function (cb) {
                        testHelper.runSqlFile(SQL_DIR + "tcs_catalog__insert.sql", TCS_CATALOG, cb);
                    }
                ], done);
            });

            after(function (done) {
                clearDb(done);
            });

            /**
             * create a http request and test it.
             * @param {String} url - the request url.
             * @param {Number} expectStatus - the expected response status code.
             * @param {Object} authHeader - the auth header for request.
             * @param {Function} cb - the call back function.
             */
            function createRequest(url, expectStatus, authHeader, cb) {
                var req = request(API_ENDPOINT)
                    .get(url)
                    .set('Accept', 'application/json');
                if (authHeader) {
                    req.set('Authorization', authHeader);
                }
                req.expect('Content-Type', /json/)
                    .expect(expectStatus)
                    .end(cb);
            }

            /**
             * develop/challenges/30400000
             */
            it('should return PAST software details', function (done) {
                request(API_ENDPOINT)
                    .get('/v2/develop/challenges/' + '30400000')
                    .set('Accept', 'application/json')
                    .expect('Content-Type', /json/)
                    .expect(200)
                    .end(function (err, res) {
                        if (err) {
                            done(err);
                        }
                        var expected = require('./test_files/expected_software_challenge_detail.json');
                        delete res.body.serverInformation;
                        delete res.body.requesterInformation;
                        // The time in test data is not constant.
                        delete res.body.postingDate;
                        delete res.body.registrationEndDate;
                        delete res.body.checkpointSubmissionEndDate;
                        delete res.body.appealsEndDate;
                        delete res.body.finalFixEndDate;
                        delete res.body.submissionEndDate;
                        delete res.body.currentPhaseEndDate;
                        delete res.body.currentPhaseRemainingTime;
                        delete res.body.registrants[0].registrationDate;
                        delete res.body.submissions[0].submissionDate;
                        assert.deepEqual(res.body, expected, 'Invalid response');
                        done();
                    });
            });

            it('should return PAST software details(no reliabilityBonus)', function (done) {
                async.waterfall([
                    function (cb) {
                        testHelper.runSqlQuery('UPDATE project_info SET value = "false" WHERE project_info_type_id = 45 AND project_id = 30400000', 'tcs_catalog', cb);
                    }, function (cb) {
                        request(API_ENDPOINT)
                            .get('/v2/develop/challenges/' + '30400000')
                            .set('Accept', 'application/json')
                            .expect('Content-Type', /json/)
                            .expect(200)
                            .end(function (err, res) {
                                if (err) {
                                    done(err);
                                    return;
                                }
                                var expected = require('./test_files/expected_software_challenge_detail.json');
                                delete expected.reliabilityBonus;

                                delete res.body.serverInformation;
                                delete res.body.requesterInformation;
                                // The time in test data is not constant.
                                delete res.body.postingDate;
                                delete res.body.registrationEndDate;
                                delete res.body.checkpointSubmissionEndDate;
                                delete res.body.appealsEndDate;
                                delete res.body.submissionEndDate;
                                delete res.body.finalFixEndDate;
                                delete res.body.currentPhaseEndDate;
                                delete res.body.currentPhaseRemainingTime;
                                delete res.body.registrants[0].registrationDate;
                                delete res.body.submissions[0].submissionDate;
                                assert.deepEqual(res.body, expected, 'Invalid response');
                                cb();
                            });
                    }
                ], function (err) {
                    if (err) {
                        done(err);
                        return;
                    }
                    done();
                });
            });

            /**
             * develop/challenges/30500000
             */
            it('should return F2F challenge details', function (done) {
                request(API_ENDPOINT)
                    .get('/v2/develop/challenges/' + '30500000')
                    .set('Accept', 'application/json')
                    .expect('Content-Type', /json/)
                    .expect(200)
                    .end(function (err, res) {
                        if (err) {
                            done(err);
                        }
                        var expected = require('./test_files/expected_f2f_challenge_detail.json');
                        delete res.body.serverInformation;
                        delete res.body.requesterInformation;
                        // The time in test data is not constant.
                        delete res.body.postingDate;
                        delete res.body.registrationEndDate;
                        delete res.body.checkpointSubmissionEndDate;
                        delete res.body.appealsEndDate;
                        delete res.body.finalFixEndDate;
                        delete res.body.submissionEndDate;
                        delete res.body.currentPhaseEndDate;
                        delete res.body.currentPhaseRemainingTime;
                        delete res.body.registrants[0].registrationDate;
                        delete res.body.submissions[0].submissionDate;
                        assert.deepEqual(res.body, expected, 'Invalid response');
                        done();
                    });
            });

            it('should return success results. The caller heffan is in the group.', function (done) {
                createRequest('/v2/develop/challenges/2001', 200, heffanAuthHeader, done);
            });

            it('should return 401 unauthorized error. The caller user is not in the group.', function (done) {
                createRequest('/v2/develop/challenges/2001', 401, userAuthHeader, done);
            });

            it('should return 401 unauthorized error. The anonymous call is not allowed for private challenge.', function (done) {
                createRequest('/v2/develop/challenges/2001', 401, null, done);
            });
        });

        describe("-- Studio Challenges Detail API --", function () {

            var SQL_DIR = __dirname + "/sqls/challengesStudio/";

            /**
             * Clear database
             * @param {Function<err>} done the callback
             */
            function clearDb(done) {
                async.waterfall([
                    function (cb) {
                        testHelper.runSqlFile(SQL_DIR + "tcs_catalog__clean", TCS_CATALOG, cb);
                    },
                    function (cb) {
                        testHelper.runSqlFile(SQL_DIR + "tcs_dw__clean", TCS_DW, cb);
                    }
                ], done);
            }

            before(function (done) {
                async.waterfall([
                    clearDb,
                    function (cb) {
                        testHelper.runSqlFile(SQL_DIR + "tcs_catalog__insert_test_data", TCS_CATALOG, cb);
                    },
                    function (cb) {
                        testHelper.runSqlFile(SQL_DIR + "tcs_dw__insert_test_data", TCS_DW, cb);
                    }
                ], done);
            });

            after(function (done) {
                clearDb(done);
            });

            /**
             * Create request to search challenges API and assert 400 http code
             * @param {String} challengeId - the challenge id
             * @param {Function} done - the callback function
             */
            function assert400(challengeId, done) {
                request(API_ENDPOINT)
                    .get('/v2/design/challenges/' + challengeId)
                    .set('Accept', 'application/json')
                    .expect('Content-Type', /json/)
                    .expect(400)
                    .end(done);
            }

            /**
             * /v2/design/challenges/10041
             */
            it("should return challenge details", function (done) {
                request(API_ENDPOINT)
                    .get('/v2/design/challenges/10041')
                    .set('Accept', 'application/json')
                    .expect('Content-Type', /json/)
                    .expect(200)
                    .end(function (err, res) {
                        var body = res.body;
                        assert.isUndefined(res.body.finalFixEndDate, 'studio challenge should not contain final fix end date');
                        assert.lengthOf(body.submissions, 1, "invalid submissions count");
                        assert.lengthOf(body.checkpoints, 1, "invalid checkpoints count");
                        assert.lengthOf(body.winners, 1, "invalid winners count");
                        //submissionTime is not constant value
                        assert.ok(body.submissions[0].submissionTime);
                        assert.ok(body.checkpoints[0].submissionTime);
                        assert.ok(body.winners[0].submissionTime);
                        delete body.submissions[0].submissionTime;
                        delete body.checkpoints[0].submissionTime;
                        delete body.registrants[0].registrationDate;
                        delete body.registrants[1].registrationDate;
                        delete body.registrants[2].registrationDate;
                        delete body.registrants[3].registrationDate;
                        delete body.winners[0].submissionTime;
                        delete body.currentPhaseEndDate;
                        testHelper.assertResponse(err,
                            res,
                            "test_files/exptected_studio_challenge_details.json",
                            done);
                    });
            });

            it('should return challenge details(submissionLimit empty)', function (done) {
                async.waterfall([
                    function (cb) {
                        testHelper.runSqlQuery("UPDATE project_info SET value = '' WHERE project_info_type_id = 51 AND project_id = 10041", 'tcs_catalog', cb);
                    }, function (cb) {
                        request(API_ENDPOINT)
                            .get('/v2/design/challenges/10041')
                            .set('Accept', 'application/json')
                            .expect('Content-Type', /json/)
                            .expect(200)
                            .end(function (err, res) {
                                var body = res.body,
                                    expected = require('./test_files/exptected_studio_challenge_details.json');
                                assert.lengthOf(body.submissions, 1, "invalid submissions count");
                                assert.lengthOf(body.checkpoints, 1, "invalid checkpoints count");
                                assert.lengthOf(body.winners, 1, "invalid winners count");
                                //submissionTime is not constant value
                                assert.ok(body.submissions[0].submissionTime);
                                assert.ok(body.checkpoints[0].submissionTime);
                                assert.ok(body.winners[0].submissionTime);
                                delete body.submissions[0].submissionTime;
                                delete body.checkpoints[0].submissionTime;
                                delete body.registrants[0].registrationDate;
                                delete body.registrants[1].registrationDate;
                                delete body.registrants[2].registrationDate;
                                delete body.registrants[3].registrationDate;
                                delete body.winners[0].submissionTime;
                                delete body.currentPhaseEndDate;
                                delete body.serverInformation;
                                delete body.requesterInformation;
                                expected.submissionLimit = '';
                                assert.deepEqual(body, expected, 'Invalid response');
                                cb();
                            });
                    }
                ], function (err) {
                    if (err) {
                        done(err);
                        return;
                    }
                    done();
                });
            });

            it('should return challenge details(no submissionLimit)', function (done) {
                async.waterfall([
                    function (cb) {
                        testHelper.runSqlQuery('DELETE FROM project_info WHERE project_info_type_id = 51 AND project_id = 10041', 'tcs_catalog', cb);
                    }, function (cb) {
                        request(API_ENDPOINT)
                            .get('/v2/design/challenges/10041')
                            .set('Accept', 'application/json')
                            .expect('Content-Type', /json/)
                            .expect(200)
                            .end(function (err, res) {
                                var body = res.body,
                                    expected = require('./test_files/exptected_studio_challenge_details.json');
                                assert.lengthOf(body.submissions, 1, "invalid submissions count");
                                assert.lengthOf(body.checkpoints, 1, "invalid checkpoints count");
                                assert.lengthOf(body.winners, 1, "invalid winners count");
                                //submissionTime is not constant value
                                assert.ok(body.submissions[0].submissionTime);
                                assert.ok(body.checkpoints[0].submissionTime);
                                assert.ok(body.winners[0].submissionTime);
                                delete body.submissions[0].submissionTime;
                                delete body.checkpoints[0].submissionTime;
                                delete body.registrants[0].registrationDate;
                                delete body.registrants[1].registrationDate;
                                delete body.registrants[2].registrationDate;
                                delete body.registrants[3].registrationDate;
                                delete body.winners[0].submissionTime;
                                delete body.currentPhaseEndDate;
                                delete body.serverInformation;
                                delete body.requesterInformation;
                                delete expected.submissionLimit;
                                assert.deepEqual(body, expected, 'Invalid response');
                                cb();
                            });
                    }
                ], function (err) {
                    if (err) {
                        done(err);
                        return;
                    }
                    done();
                });
            });

            it('should return challenge details(no reliabilityBonus)', function (done) {
                async.waterfall([
                    function (cb) {
                        testHelper.runSqlQuery('UPDATE project_info SET value = "false" WHERE project_info_type_id = 45 AND project_id = 10041', 'tcs_catalog', cb);
                    }, function (cb) {
                        request(API_ENDPOINT)
                            .get('/v2/design/challenges/10041')
                            .set('Accept', 'application/json')
                            .expect('Content-Type', /json/)
                            .expect(200)
                            .end(function (err, res) {
                                var body = res.body,
                                    expected = require('./test_files/exptected_studio_challenge_details.json');
                                assert.lengthOf(body.submissions, 1, "invalid submissions count");
                                assert.lengthOf(body.checkpoints, 1, "invalid checkpoints count");
                                assert.lengthOf(body.winners, 1, "invalid winners count");
                                //submissionTime is not constant value
                                assert.ok(body.submissions[0].submissionTime);
                                assert.ok(body.checkpoints[0].submissionTime);
                                assert.ok(body.winners[0].submissionTime);
                                delete body.submissions[0].submissionTime;
                                delete body.registrants[0].registrationDate;
                                delete body.registrants[1].registrationDate;
                                delete body.registrants[2].registrationDate;
                                delete body.registrants[3].registrationDate;
                                delete body.checkpoints[0].submissionTime;
                                delete body.winners[0].submissionTime;
                                delete body.currentPhaseEndDate;
                                delete body.serverInformation;
                                delete body.requesterInformation;
                                delete expected.reliabilityBonus;
                                assert.deepEqual(res.body, expected, 'Invalid response');
                                cb();
                            });
                    }
                ], function (err) {
                    if (err) {
                        done(err);
                        return;
                    }
                    done();
                });
            });


            /**
             * /v2/design/challenges/xyz
             */
            it("should return 400 error if contestId is not number", function (done) {
                assert400("xyz", done);
            });

            /**
             * /v2/design/challenges/0
             */
            it("should return 400 error if contestId is 0", function (done) {
                assert400("0", done);
            });

            /**
             * /v2/design/challenges/-1
             */
            it("should return 400 error if contestId is -1", function (done) {
                assert400("-1", done);
            });

            /**
             * /v2/design/challenges/1.23
             */
            it("should return 400 error if contestId is 1.23", function (done) {
                assert400("1.23", done);
            });

            /**
             * /v2/design/challenges/10000000000000000
             */
            it("should return 400 error if contestId is too big number", function (done) {
                assert400("10000000000000000", done);
            });
        });
    });

});
