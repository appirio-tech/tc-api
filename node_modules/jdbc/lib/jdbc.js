/*
 * Original source from https://github.com/CraZySacX/node-jdbc
 */

var EventEmitter = require('events').EventEmitter;
var java = require('java');
var sys = require('sys');
var _ = require('underscore');

var defaultLog = function(msg){
    console.log(new Date() + " - " + msg);
};

function getType(value) {
	if (_.isString(value)) {
		return 'string';
	} else if (_.isString(date)) {
		return 'date';
	} else if (_.isNumber(value) && _.isNaN(value) && _.isFinite(value) && value % 1 === 0) {
		return 'int';
	} else if (_.isNumber(value) && _.isNaN(value) && _.isFinite(value) && value === +value && value !== (n|0)) {
		return 'float';
	}

	return null;
}

function trim1 (str) {
    return (str == null ? null : str.replace(/^\s\s*/, '').replace(/\s\s*$/, ''));
}

function s4() {
  return Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1);
}

function guid() {
  return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
         s4() + '-' + s4() + s4() + s4();
}

/**
 * Constructor
 */
var JDBCConn = function (config, log) {
    EventEmitter.call(this);
    this._config = config;
    this._conn = null;
    this._guid = guid();

    this._log = log || defaultLog;

    this.initialize(config);
}

sys.inherits(JDBCConn, EventEmitter);

JDBCConn.prototype.initialize = function(config) {
    var self = this;
    self._config = config;

    var minPoolSize = self._config.minpoolsize | 5;
    java.classpath.push(self._config.libpath);

    // these are asynchronous calls
    try {
        java.newInstance(self._config.drivername, function(err, driver) {
            if (err) {
                self.emit('error', err);
            } else {
                java.callStaticMethod('java.sql.DriverManager','registerDriver', driver, function(err, result) {
                    if (err) {
						self.emit('error', err);
                    }
                });
            }
        });
    } catch(e) {
        self.emit('error', err);
    }
};

JDBCConn.prototype.connect = function(callback) {
    var self = this;
    java.callStaticMethod('java.sql.DriverManager','getConnection', self._config.url, function(err, conn) {
		if (err) {
			self.emit('error', err);
		} else {
			self._conn = conn;
			if (callback) callback(null);
		}
	});
};

JDBCConn.prototype.disconnect = function() {
    var self = this;
    if (self.isConnected()) {
        self._conn.closeSync();
    }
    self.emit('close', null);
};

JDBCConn.prototype.isConnected = function() {
    var self = this;
    return (self._conn != null && !self._conn.isClosedSync());
};

JDBCConn.prototype.handleResult = function(err, resultset) {
    var self= this;
    var callback = self._callback;

    var resultset = resultset;
    if (err) {
        if (callback) callback(err, null);
    } else {
        resultset.getMetaData(function(err,rsmd) {
            if (err) {
                if (callback) callback(err, null);
            } else {
                var cc = rsmd.getColumnCountSync();
                var results = [];
                var next = resultset.nextSync();

                while (next) {
                    var row = {};

                    for(var i = 1; i <= cc; i++) {
                        var colname = rsmd.getColumnNameSync(i);
                        var coltype = rsmd.getColumnTypeNameSync(i);
                        var colscale = rsmd.getScaleSync(i);
                        if (coltype.indexOf('int') != -1) {
                            row[colname] = resultset.getIntSync(i);
                        } else if (coltype.indexOf('decimal') != -1) {
                            if (colscale == 0) {
                                row[colname] = resultset.getIntSync(i);
                            } else {
                                row[colname] = parseFloat(resultset.getFloatSync(i).toFixed(colscale));
                            }
                        } else if (coltype.indexOf('float') != -1) {
                            row[colname] = resultset.getFloatSync(i);
                        }   else if (coltype.indexOf('date') != -1) {
                            row[colname] = new Date(resultset.getDateSync(i).getTimeSync());
                        } else if (coltype.indexOf('varchar') != -1) {
                            row[colname] = trim1(resultset.getStringSync(i));
                        }   else if (coltype.indexOf('boolean') != -1) {
                            row[colname] = resultset.getBooleanSync(i);
                        }
                    }
                    self._log('Row: ' + JSON.stringify(row), 'debug');
                    results.push(row);
                    next = resultset.nextSync();
                }
                // self.emit('execute', null, results);
                self.emit('finish');
                if (callback) callback(err, results);
            }
        });
    }
};

JDBCConn.prototype.query = function(sql, variables, callback, config) {
	var self = this;

	self._sql = sql;
    self._callback = callback;
    self._variables = variables;

	for (var key in config) {
		if (config.hasOwnProperty(key) && _.isFunction(config[key]) ) {
			self._log('Adding listener to ' + key + ' event', 'debug');
			self.on(key, config[key]);
		}
	}
	// ignore async and cast

	return self;
};

JDBCConn.prototype.select = function(sql) {
	var self = this;
	self._sql = 'select ' + sql;

	return self;
};

JDBCConn.prototype.execute = function() {
	var self = this;

	if (self._sql == 'BEGIN WORK') {
		self._conn.setAutoCommitSync(false);
	} else if (self._sql == 'ROLLBACK WORK') {
		self._conn.rollbackSync();
	} else if (self._sql == 'COMMIT WORK') {
		self._conn.commitSync();
	} else if (self._sql.toLowerCase().indexOf('insert') === 0 || self._sql.toLowerCase().indexOf('update') === 0) {
		self.executeUpdate(self._sql, self._variables, self._callback);
	} else {
		self.executeQuery(self._sql, self._variables, self._callback);
	}
};

JDBCConn.prototype.executeQuery = function(sql, variables, callback) {
	var self = this;
	self.emit('start', sql);
    if (variables === null || variables.length === 0) {
        // these are asynchronous calls
        try {
            self._conn.createStatement(function(err, statement) {
                if (err) {
                    if (callback) callback(err, null);
                } else {
                    statement.executeQuery(sql, function(err, resultset) {
                        self.handleResult(err, resultset);
                    });
                }
            });
        } catch(e) {
            if (callback) callback(err, null);
        }
    } else {
        // these are asynchronous calls
        try {
            self._conn.prepareStatement(sql, function(err, statement) {
                if (err) {
                    if (callback) callback(err, null);
                } else {
                    for (var i = 0; i < variables.length; i++) {
                    	var type = getType(variables[i]);
                        if (type == 'int') {
                            statement.setIntSync(i + 1, variables[i]);
                        } else if (type == 'float') {
                            statement.setFloatSync(i + 1, variables[i]);
                        } else if (type == 'string') {
                            statement.setStringSync(i + 1, str);
                        } else if (type == 'date') {
                            var date = java.newInstanceSync("java.util.Date");
                            date.setTimeSync(new Date(variables[i]).getTime());
                            statement.setDateSync(i + 1, date);
                        } else if (callback) {
                            if (callback) callback("Invalid parameter type", null);
                        }
                    }
                    statement.executeQuery(function(err, resultset) {
                        self.handleResult(err, resultset);
                    });
                }
            });
        } catch (e) {
            if (callback) callback(e, null);
        }
    }
};

JDBCConn.prototype.executeUpdate = function(sql, variables, callback) {
	var self = this;
	self.emit('start', sql);

    if (variables === null || variables.length === 0) {
        // these are asynchronous calls
        try {
            self._conn.createStatement(function(err, statement) {
                if (err) {
                    // self.emit('execute', err, null);
                    if (callback) callback(err, null);
                } else {
                    statement.executeUpdate(sql, function(err, resultset) {
                        self.handleResult(err, resultset);
                    });
                }
            });
        } catch (e) {
            if (callback) callback(e, null);
        }
    } else {
        // these are asynchronous calls
        try {
            self._conn.prepareStatement(sql, function(err, statement) {
                if (err) {
                    self.emit('execute', err, null);
                    if (callback) callback(err, null);
                } else {
                    for (var i = 0; i < variables.length; i++) {
                        var type = getType(variables[i]);
                        if (type == 'int') {
                            statement.setIntSync(i + 1, variables[i]);
                        } else if (type == 'float') {
                            statement.setFloatSync(i + 1, variables[i]);
                        } else if (type == 'string') {
                            statement.setStringSync(i + 1, variables[i]);
                        } else if (type == 'date') {
                            var date = java.newInstanceSync("java.util.Date");
                            date.setTimeSync(new Date(variables[i]).getTime());
                            statement.setDateSync(i + 1, date);
                        } else if (callback) {
                            if (callback) callback("Invalid parameter type", null);
                        }
                    }
                    statement.executeUpdate(function(err, resultset) {
                        self.handleResult(err, resultset);
                    });
                }
            });
        } catch (e) {
            if (callback) callback(e, null);
        }
    }
};

module.exports = JDBCConn;
